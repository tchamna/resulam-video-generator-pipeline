"""
Chapter Video Combiner  • 2025‑07‑24 (k)
────────────────────────────────────────────────────────────────────────────
Stitch the single‑sentence videos generated by *multi_language_video_generator.py*
into **multiple videos per chapter**, shuffling the sentence order inside each
chapter and exporting in fixed-size chunks (default 10 clips per file):

    nufi_chapter_1_chunk_01.mp4
    nufi_chapter_1_chunk_02.mp4
    …
    nufi_chapter_32_chunk_01.mp4

Robustness:
• Corrupt/missing clips are skipped with a warning (⚠) instead of crashing.
• Every VideoFileClip is explicitly closed to avoid FD/temp exhaustion.
• TEMP_DIR lets you move both temp files and final outputs away from a cramped C: drive.

Tested with MoviePy 1.x. If you upgrade to 2.x, switch the import line as noted.
"""

from __future__ import annotations
import os, random, re, tempfile
from pathlib import Path
from typing import List, Dict, Iterable
import time

# ── MoviePy v1.x imports ───────────────────────────────────────────────
from moviepy.editor import VideoFileClip, concatenate_videoclips
# from moviepy import VideoFileClip, concatenate_videoclips  # ← use this for MoviePy 2.x

# ── USER SETTINGS ──────────────────────────────────────────────────────
LANGUAGE  = "Nufi"   # Only one language is present in the folder
LANGUAGE  = "Duala"   # Only one language is present in the folder
MODE      = "lecture" # "lecture" or "homework"
ROOT      = Path(r"G:/My Drive/Data_Science/Resulam/Phrasebook_Audio_Video_Processing_production")
FPS       = 24
FFMPEG_THREADS_PER_JOB = 4
SHUFFLE_SEED = None          # Set an int if you want deterministic shuffles
TEMP_DIR  = Path("D:/moviepy_temp")   # Temp + output location
CHUNK_SIZE = 10               # ← number of sentence videos per output file

# ── FOLDER LAYOUT (mirrors the generator script) ───────────────────────
VIDEO_DIR  = ROOT / "Python_Scripts_Resulam_Phrasebooks_Audio_Processing"
VIDEO_PATTERN = "{lang_lower}_sentence_{id}.mp4" # pattern for single-sentence clips
START_CHAPTER = 12  # this is the chapter we want to start from; by default it is 1

# ── TEMP DIR PREP ──────────────────────────────────────────────────────
def _prepare_tempdir() -> None:
    """Redirect MoviePy/FFmpeg temp files to a roomy drive."""
    if TEMP_DIR is None:
        return
    TEMP_DIR.mkdir(parents=True, exist_ok=True)
    os.environ["TMPDIR"] = os.environ["TEMP"] = os.environ["TMP"] = str(TEMP_DIR)
    tempfile.tempdir = str(TEMP_DIR)
    print(f"ℹ Temporary files redirected to {TEMP_DIR}")

# ── HELPERS ────────────────────────────────────────────────────────────
def build_paths(lang: str,mode:str) -> Dict[str, Path]:
    lang_lower = lang.lower()
    out_dir = VIDEO_DIR / f"{lang.title()}/{mode.title()}"
    txt = ROOT / f"Languages/{lang}Phrasebook/{lang_lower}_english_french_phrasebook_sentences_list.txt"
    if not out_dir.exists():
        raise FileNotFoundError(f"Sentence‑video folder not found: {out_dir}")
    if not txt.exists():
        raise FileNotFoundError(f"Cannot locate sentence list: {txt}")
    return {"lang_lower": lang_lower, "out_dir": out_dir, "sent_txt": txt}

def parse_chapters(txt_file: Path) -> Dict[int, List[int]]:
    """Return {chapter_number: [sentence_id,…]} preserving original order."""
    chapters: Dict[int, List[int]] = {}
    current = None
    with open(txt_file, encoding="utf-8") as fh:
        for ln in fh:
            if "|" not in ln:
                continue
            try:
                id_part, en_raw = ln.split(")", 1)
                sid = int(id_part.strip())
            except ValueError:
                continue
            english = en_raw.split("|", 1)[0].strip().lower()
            if english.startswith("chapter"):
                m = re.search(r"chapter\s+(\d+)", english)
                current = int(m.group(1)) if m else (current or 0) + 1
            if current is None:
                continue
            chapters.setdefault(current, []).append(sid)
    return chapters

def gather_clips(sentence_ids: Iterable[int], lang_lower: str, out_dir: Path) -> List[Path]:
    paths = [out_dir / VIDEO_PATTERN.format(lang_lower=lang_lower, id=sid) for sid in sentence_ids]
    return [p for p in paths if p.exists()]

def _open_clip(path: Path):
    """Safely open a clip; return None if ffmpeg chokes or file is corrupt."""
    try:
        return VideoFileClip(str(path))
    except Exception as e:
        print(f"⚠ Skipping {path.name}: {e}")
        return None

def chunk(lst: List[Path], size: int) -> Iterable[List[Path]]:
    for i in range(0, len(lst), size):
        yield lst[i:i + size]

def write_chunk(chap_idx: int, chunk_idx: int, clip_paths: List[Path], lang_lower: str) -> None:
    if not clip_paths:
        return
    clips = []
    for p in clip_paths:
        c = _open_clip(p)
        if c is not None:
            clips.append(c)
    if not clips:
        print(f"⚠ Chapter {chap_idx} chunk {chunk_idx:02d}: all clips unreadable – skipped")
        return

    print(f"▶ Chapter {chap_idx} chunk {chunk_idx:02d}: concatenating {len(clips)} clips …")
    final = concatenate_videoclips(clips, method="compose")

    out_file = TEMP_DIR / f"{lang_lower}_chapter_{chap_idx}_chunk_{chunk_idx:02d}.mp4"
    tmp_file = out_file.with_suffix(".tmp.mp4")
    final.write_videofile(
        str(tmp_file), fps=FPS, codec="libx264", audio_codec="aac",
        threads=FFMPEG_THREADS_PER_JOB,
        ffmpeg_params=["-pix_fmt", "yuv420p", "-movflags", "+faststart"],
        preset="ultrafast", logger=None,
    )

    final.close()
    for c in clips:
        c.close()

    tmp_file.replace(out_file)
    print(f"✅ {out_file.name} written")



def write_chunk(chap_idx: int, chunk_idx: int, clip_paths: List[Path], lang_lower: str) -> None:
    if not clip_paths:
        return
    clips = []
    for p in clip_paths:
        c = _open_clip(p)
        if c is not None:
            clips.append(c)
    if not clips:
        print(f"⚠ Chapter {chap_idx} chunk {chunk_idx:02d}: all clips unreadable – skipped")
        return

    print(f"▶ Chapter {chap_idx} chunk {chunk_idx:02d}: concatenating {len(clips)} clips …")
    final = concatenate_videoclips(clips, method="compose")

    out_file = TEMP_DIR / f"{lang_lower}_chapter_{chap_idx}_chunk_{chunk_idx:02d}.mp4"
    tmp_file = out_file.with_suffix(".tmp.mp4")

    # Use a try-except block to handle potential write errors and ensure cleanup
    try:
        final.write_videofile(
            str(tmp_file), fps=FPS, codec="libx264", audio_codec="aac",
            threads=FFMPEG_THREADS_PER_JOB,
            ffmpeg_params=["-pix_fmt", "yuv420p", "-movflags", "+faststart"],
            preset="ultrafast", logger=None,
        )
        
        # Introduce a short delay to ensure FFmpeg releases the file lock
        time.sleep(0.5)  # half a second should be sufficient

        # Attempt the rename operation
        tmp_file.replace(out_file)
        print(f"✅ {out_file.name} written")

    except PermissionError as e:
        print(f"❌ Failed to rename file: {e}")
        # Optionally, you can log this to a file for later review

    except Exception as e:
        print(f"❌ An error occurred during file processing: {e}")

    finally:
        # Ensure all clips are closed, regardless of success or failure
        final.close()
        for c in clips:
            c.close()
# ── MAIN ───────────────────────────────────────────────────────────────
          
def main() -> None:
    _prepare_tempdir()
    random.seed(SHUFFLE_SEED)

    paths = build_paths(LANGUAGE, MODE)
    chapter_map = parse_chapters(paths["sent_txt"])
    if not chapter_map:
        print("⚠ No chapters detected – nothing to do.")
        return

    # Filter the chapter_map to start from chapter x
    chapter_map = {chap: ids for chap, ids in chapter_map.items() if chap >= START_CHAPTER}
    print(f"✅ Starting processing from Chapter {START_CHAPTER}")

    for chap_num, sentence_ids in chapter_map.items():
        clip_paths = gather_clips(sentence_ids, paths["lang_lower"], paths["out_dir"])
        
        if not clip_paths:
            print(f"⚠ Chapter {chap_num}: no clips found – skipped")
            continue
        
        # For Lecture mode, keep original order
        # For Homework mode, shuffle the clips
        if MODE == "homework":             
            random.shuffle(clip_paths)
        
        for chunk_idx, sub in enumerate(chunk(clip_paths, CHUNK_SIZE), start=1):
            write_chunk(chap_num, chunk_idx, sub, paths["lang_lower"])


if __name__ == "__main__":
    main()
